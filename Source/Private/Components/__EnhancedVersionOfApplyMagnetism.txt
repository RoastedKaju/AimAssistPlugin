void RotateTowardsTargetEnhanced(float DeltaTime, AActor* Target, float InterpSpeed = 5.0f, float DeadZoneAngle = 1.0f)
{
    if (!Target) return;
    
    FRotator CurrentRot = GetControlRotation();
    FVector CurrentLoc = GetPawn() ? GetPawn()->GetActorLocation() : GetOwner()->GetActorLocation();
    FVector TargetLoc = Target->GetActorLocation();
    
    // Calculate direction and check if target is valid
    FVector ToTarget = TargetLoc - CurrentLoc;
    if (ToTarget.SizeSquared() < KINDA_SMALL_NUMBER) return;
    
    FRotator TargetRot = ToTarget.Rotation();
    
    // Optional: Maintain current pitch or roll if needed
    // TargetRot.Pitch = CurrentRot.Pitch; // Uncomment if you want to keep current pitch
    // TargetRot.Roll = CurrentRot.Roll;   // Uncomment if you want to keep current roll
    
    // Check if we're already close enough
    float AngleDiff = FMath::Abs(CurrentRot.Yaw - TargetRot.Yaw);
    if (AngleDiff < DeadZoneAngle) return;
    
    // Interpolate
    FRotator NewRot = FMath::RInterpTo(CurrentRot, TargetRot, DeltaTime, InterpSpeed);
    SetControlRotation(NewRot);
}